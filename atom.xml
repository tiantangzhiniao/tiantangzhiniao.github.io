<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Leo's blog]]></title>
  <subtitle><![CDATA[活到老，学到老：Never too old to learn]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2015-07-13T09:14:18.120Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[Yu Le]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Java之注解]]></title>
    <link href="http://yoursite.com/2015/07/13/zhujie/"/>
    <id>http://yoursite.com/2015/07/13/zhujie/</id>
    <published>2015-07-13T09:11:00.000Z</published>
    <updated>2015-07-13T09:14:18.120Z</updated>
    <content type="html"><![CDATA[<p>我们在编程时会经常看到@Override，@Deprecate这样的代码，这就是Java注解的内容。<br>Java 注解，从名字上看是注释，解释。但功能却不仅仅是注释（注释是对程序代码的补充说明，编译运行时会自动忽略）那么简单。注解（Annotation）为我们在代码中添加信息提供了一种形式化的方法，是我们可以在稍后某个时刻方便地使用这些数据（通过解析注解来使用这些数据）。包java.lang.annotation中包含所有定义自定义注解所需用到的原注解和接口。注解的作用如下：</p>
<ul>
<li>生成文档。这是最常见的，也是java最早提供的注解。常用的有@see,@param,@return 等；</li>
<li>跟踪代码依赖性，实现替代配置文件功能。比较常见的是spring2.5开始的基于注解配置。作用就是减少配置。现在的框架基本都使用了这种配置来减少配置文件的数量；</li>
<li>在编译时进行格式检查。如@Override放在方法前，如果你这个方法并不是覆盖了超类方法，则编译时就能检查出；<br>常见的注解有：<br>内建注解：<br>@Deprecated：将该项标记为过时的。<br>@SuppressWarnings：阻止某个/某些给定类型的警告信息<br>@Override： 检查该方法是否覆盖了某个超类的方法。（只能修饰方法，不能修饰变量和对象）<br>元注解：<br>@Target： 指定可以使用这个注解的那些内容<br>@Retention： 指定这个注解可以保留多久<br>@Documented： 指定这个注解应该包含在注解项的文档中<br>@Inherited： 指定一个注解，作用在父类时，能够自动被子类继承<br>注解的语法：<br>注解是通过注解接口来定义的：<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">modifiers <span class="variable">@interface</span> <span class="constant">AnnotationName</span> &#123;</span><br><span class="line">    type elementName() [default value ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>例如：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tmser.annotation;</span><br><span class="line"><span class="keyword">public</span> @<span class="class"><span class="keyword">interface</span> <span class="title">TestA</span> </span>&#123;</span><br><span class="line">     <span class="comment">//这里定义了一个空的注解，它能干什么呢。我也不知道，但他能用。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>我们在编程时会经常看到@Override，@Deprecate这样的代码，这就是Java注解的内容。<br>Java 注解，从名字上看是注释，解释。但功能却不仅仅是注释（注释是对程序代码的补充说明，编译运行时会自动忽略）那么简单。注解（Annotation）为我们在代码中添]]>
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java之反射]]></title>
    <link href="http://yoursite.com/2015/07/03/fanshe/"/>
    <id>http://yoursite.com/2015/07/03/fanshe/</id>
    <published>2015-07-03T06:17:02.000Z</published>
    <updated>2015-07-03T06:21:26.557Z</updated>
    <content type="html"><![CDATA[<p>最近心情真是低到了谷底，各种不顺，确实自己刚入股市，心态也有问题，能在股市行走的人一定是心态非常好的人，能够不以物喜，不以己悲，对于盈亏能够及时身退。最近的学习效率也是够低的。今天就总结一下Java的反射机制吧。学习好反射机制对于理解框架是很有意义的。<br>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。<br>Java反射机制主要提供了以下功能： </p>
<ul>
<li>在运行时判断任意一个对象所属的类；</li>
<li>在运行时构造任意一个类的对象；</li>
<li>在运行时判断任意一个类所具有的成员变量和方法；</li>
<li>在运行时调用任意一个对象的方法；</li>
<li>生成动态代理。<br>在 Java 中，主要由以下类来实现反射，这些类大多都位于 java.lang.reflect 包中。 Class (java.lang.Class<t>)：表示正在运行的 Java 应用程序中的类和接口。Field：代表类或接口的成员，及相关信息。Method：提供类或接口上单独某个方法（以及访问该方法）的信息。Constructor：提供关于类的单个构造方法的信息以及对它的访问权限。Array类：提供了动态创建和访问Java数组的方法。关于这些类的具体方法还是参考API文档吧。<br>下面看一段代码<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Demo&#123;</span><br><span class="line">    //other codes...</span><br><span class="line">&#125;</span><br><span class="line">class hello&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Class&lt;?&gt; demo1=null;</span><br><span class="line">        Class&lt;?&gt; demo2=null;</span><br><span class="line">        Class&lt;?&gt; demo3=null;</span><br><span class="line">        try&#123;</span><br><span class="line">            //一般尽量采用这种形式</span><br><span class="line">            demo1=Class.forName("Reflect.Demo");</span><br><span class="line">        &#125;catch(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        demo2=new Demo().getClass();</span><br><span class="line">        demo3=Demo.class;</span><br><span class="line">        System.out.println("类名称   "+demo1.getName());</span><br><span class="line">        System.out.println("类名称   "+demo2.getName());</span><br><span class="line">        System.out.println("类名称   "+demo3.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</t></li>
</ul>
<p>这段简单的代码就是输出类的名称。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近心情真是低到了谷底，各种不顺，确实自己刚入股市，心态也有问题，能在股市行走的人一定是心态非常好的人，能够不以物喜，不以己悲，对于盈亏能够及时身退。最近的学习效率也是够低的。今天就总结一下Java的反射机制吧。学习好反射机制对于理解框架是很有意义的。<br>JAVA反射机]]>
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java之抽象类和接口]]></title>
    <link href="http://yoursite.com/2015/06/30/jiekou/"/>
    <id>http://yoursite.com/2015/06/30/jiekou/</id>
    <published>2015-06-30T12:05:27.000Z</published>
    <updated>2015-06-30T12:10:50.845Z</updated>
    <content type="html"><![CDATA[<p>今天总结一下Java高级编程中大家经常搞混的抽象类和接口。</p>
<ol>
<li>抽象类<br>在Java中，当一个类被abstract关键字修饰时，该类称为抽象类。抽象类语法如下：<br>  <code>public abstract class 类名称{}</code><br>在语法中：abstract关键字表示该类被定义为抽象类。普通类与抽象类相比，主要有一下几点区分：</li>
</ol>
<ul>
<li>抽象类需要修饰符abstract，普通方法不需要。</li>
<li><p>普通类可以实例化，抽象类不能实例化。<br>当一个类被定义为抽象类是时，它可以包含各种类型的成员，包括属性、方法等，其中方法又可以分为普通方法和抽象方法。语法格式如下：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="constant">Public</span> abstract <span class="class"><span class="keyword">class</span> 类名称&#123;</span></span><br><span class="line">    修饰符 abstract 返回类型 方法名（）;</span><br><span class="line">    修饰符 返回类型 方法名（）&#123;</span><br><span class="line">          方法体</span><br><span class="line">          &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p> 在Java中，当一个类的方法被abstract关键字修饰时，该方法称为抽象方法。抽象方法所在的类必须是定义为抽象类。当一个方法被定义为抽象方法后，意味着该方法不会具体的实现，而是在抽象类的子类中通过方法的重写进行实现。抽象方法是没有方法体的。</p>
</li>
</ul>
<ol>
<li>接口<br>简单的说，接口就是一个不能实例化的类型。接口类型的定义类似于类的定义，语法有如下：<code>Public interface 接口名{//接口成员}</code><br>和抽象类不同，定义接口使用interface修饰符，访问修饰只能是public，且可选。接口成员可以是全局变量和公共的抽象方法。与抽象类一样，接口要使用也必须通过子类，子类通过implement是关键字实现。<br>一个普通类只能继承一个父类，但能同时继承多个接口，也可以同时继承抽象类和实现接口。</li>
<li>两者的差别<br>接口作为系统与外界交互的窗口，接口体现是一种规范。当一个程序中使用接口时，接口是多个模块之间的耦合标准；当多个应用程序之间使用时，接口时多个程序之间的通信标准。因此一个系统中的接口不应该经常改变。抽象类则不一样，抽象类作为系统中多个子列共同的父类，它所体现的是一种模板设计。抽象做为多个子类的抽象父类，可以被当场系统实现过程中的中间产品，这个中间产品已经实现类系统的部分功能（那些已经提供实现的方法），但这个产品依然不能当成最终产品，必须有更进一步的完善。两者的用法差别如下：</li>
</ol>
<ul>
<li>接口只能包含抽象方法，不包含已经提供实现的方法；抽象类则完全可以包含普通方法。</li>
<li>接口里不能定义静态方法；抽象类里可以静态方法。</li>
<li>接口里只能定义静态常量属性，不能定义普通属性，即只能用public static final修饰；抽象类则即可以定义普通属性，也可以定义静态常量属性。</li>
<li>一个类最多只能有一个直接父类，包括抽象类；但一个类可以直接实现多个接口，通过实现多个接口可以弥补Java继承的不足</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天总结一下Java高级编程中大家经常搞混的抽象类和接口。</p>
<ol>
<li>抽象类<br>在Java中，当一个类被abstract关键字修饰时，该类称为抽象类。抽象类语法如下：<br>  <code>public abstract class 类名称{}</cod]]>
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java之集合框架]]></title>
    <link href="http://yoursite.com/2015/06/29/jihe/"/>
    <id>http://yoursite.com/2015/06/29/jihe/</id>
    <published>2015-06-29T13:36:51.000Z</published>
    <updated>2015-06-29T13:41:46.739Z</updated>
    <content type="html"><![CDATA[<p>最近在复习和巩固Java的高级编程，让我一下子也明白了以前很多不清楚的疑点，今天就先总结一下Java中的集合框架。<br>集合框架是为表示和操作集合而规定的一种统一的标准的体系结构。任何集合框架都包含三大块内容：对外的接口、接口的实现和对集合运算的算法。接口：即表示集合的抽象数据类型。接口提供了让我们对集合中所表示的内容进行单独操作的可能。实现：也就是集合框架中接口的具体实现。实际它们就是那些可复用的数据结构。<br>Java的集合框架提供了一套设计优良的接口和类，使程序员操作成批的数据或对象元素极为方便，极大的减化了程序员编程时的负担。<br>集合与数组的区别：</p>
<ul>
<li>数组是定长，即创建后固定不变；集合是不定长，其 长度可动态增长或减少。</li>
<li>数组是同构的，即数组中的元素是相同的类型；集合可以是异构的，当然也可通过泛型创建类型安全的同构集合。</li>
<li>数组中可以存放基本数据类型或对象；集合只存放对象。<br><img src="/picture/jihe.bmp" alt=""><br>由上图可看出Java的集合框架的核心接口为：Collection、Map、Iterator，这三个接口为以后要使用的最重点的接口。按具体集合类使用上的特性来分的话，主要有三类：List、Set 和 Map。他们的特点如下：</li>
<li>List 是有序的，但允许重复</li>
<li>Set 是无序的，但不允许重复</li>
<li>Map 表现的是键值对的概念<br>如上图中所示，其中在编程实践中最常用到的类有：ArrayList，LinkedList，HashSet和HashMap,下面通过代码举一个例子<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class TestList &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">		<span class="comment">//Object[] list = new Object[10] ;</span></span><br><span class="line">		<span class="comment">//String[] list = new String[10] ;下面的是使用泛型创建的链表类</span></span><br><span class="line">		List&lt;<span class="keyword">String</span>&gt; list = <span class="keyword">new</span> LinkedList&lt;<span class="keyword">String</span>&gt;() ;</span><br><span class="line">		<span class="comment">//向数组添加元素，调用了list的add（）方法</span></span><br><span class="line">		list.<span class="built_in">add</span>(<span class="string">"abc"</span>) ;</span><br><span class="line">		list.<span class="built_in">add</span>(<span class="string">"abc"</span>) ;</span><br><span class="line">		list.<span class="built_in">add</span>(<span class="string">"sdfddf"</span>) ;</span><br><span class="line">		<span class="comment">//都是 String</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; list.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">			<span class="keyword">String</span>  s = (<span class="keyword">String</span>)list.<span class="built_in">get</span>(i) ;<span class="comment">//不使用泛型的话必须得强制类型转换</span></span><br><span class="line">		&#125;</span><br><span class="line">		System.out.<span class="built_in">println</span>(list.<span class="built_in">size</span>());</span><br><span class="line">		<span class="comment">//使用get()方法得到list[0]</span></span><br><span class="line">		System.out.<span class="built_in">println</span>(list.<span class="built_in">get</span>(<span class="number">0</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class TestMap &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Map&lt;String,Object&gt; map = new HashMap&lt;String,Object&gt;() ;</span><br><span class="line">		</span><br><span class="line">		map.put("cname", "张三") ;</span><br><span class="line">		map.put("score", 500) ;</span><br><span class="line">		map.put("cname","小三") ;</span><br><span class="line">		//List&lt;Customer&gt;</span><br><span class="line">//		List&lt;Map&lt;String,Object&gt;&gt;</span><br><span class="line">		//获得所有的key</span><br><span class="line">		Set&lt;String&gt; keys = map.keySet() ;</span><br><span class="line">		for(String k : keys)&#123;</span><br><span class="line">			Object v = map.get(k) ;</span><br><span class="line">			System.out.println("key="+k+",value="+v);</span><br><span class="line">		&#125;</span><br><span class="line">		//获得所有的value</span><br><span class="line">		Collection&lt;Object&gt; col = map.values() ;</span><br><span class="line">		for (Object o : col) &#123;</span><br><span class="line">			System.out.println(o);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的2个代码简单的示范了list类和map类的常用方法，具体的方法我们可以查阅Java的API，这也是学习的关键，因为我们不能记住所有的方法，当我们用到某个类是一定要学会查阅API，这才是学习的方法。<br>同时我列举一下面试中Java会常问的HashMap 与 Hashtable的区别，这两者在方式上几乎一致，他们的区别在于：</p>
<ul>
<li>Hashtable 继承了陈旧的 Dictionary 类，HashMap 是Java2 引进的 Map 接口的一个实现。</li>
<li>Hashtable 是线程安全的，也就是说是同步的，速度慢；而HashMap是线程序非安全的，即是异步的，速度快。</li>
<li>HashMap 允许让你将 null 作为 key (这个key也只能有一个)，Hashtable 不允许 null 作为 key。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近在复习和巩固Java的高级编程，让我一下子也明白了以前很多不清楚的疑点，今天就先总结一下Java中的集合框架。<br>集合框架是为表示和操作集合而规定的一种统一的标准的体系结构。任何集合框架都包含三大块内容：对外的接口、接口的实现和对集合运算的算法。接口：即表示集合的抽]]>
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[编码问题]]></title>
    <link href="http://yoursite.com/2015/06/12/bianma/"/>
    <id>http://yoursite.com/2015/06/12/bianma/</id>
    <published>2015-06-12T06:47:34.000Z</published>
    <updated>2015-06-12T06:51:14.819Z</updated>
    <content type="html"><![CDATA[<p>很多人在编程的过程中一定有过被汉字编码困扰过，有时莫名其妙的就会出现一些乱码，今天我就把几个常见的编码简单介绍一下。</p>
<ol>
<li>ASCII码<br>我们知道，在计算机内部，所有的信息最终都表示为一个二进制的字符串。每一个二进制位（bit）有0和 1两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从0000000到11111111。上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为ASCII码，一直沿用至今。ASCII码一共规定了128个字符的编码，比如空格“SPACE”是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的1位统一规定为0。</li>
<li>非ASCII编码<br>英语用128个符号编码就够了，但是用来表示其他语言，128个符号是不够的。比如，在法语中，字母上方有注音符号，它就无法用ASCII码表示。于是，一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号。比如，法语中的é的编码为130（二进制10000010）。这样一来，这些欧洲国家使用的编码体系，可以表示最多256个符号。但是，这里又出现了新的问题。不同的国家有不同的字母，因此，哪怕它们都使用256个符号的编码方式， 代表的字母却不一样。比如，130在法语编码中代表了é，在希伯来语编码中却代表了字母Gimel (ג)，在俄语编码中又会代表另一个符号。但是不管怎样，所有这些编码方式中，0—127表示的符号是一样的，不一样的只是128—255的这一段。至于亚洲国家的文字，使用的符号就更多了，汉字就多达10万左右。一个字节只能表示256种符号，肯定 是不够的，就必须使用多个字节表达一个符号。比如，简体中文常见的编码方式是GB2312，使用两个字节表示一个汉字，所以理论上最多可以表示256x256=65536个符号。中文编码的问题需要专文讨论，这篇笔记不涉及。这里只指出，虽然都是用多个字节表示一个符号，但是GB类的汉字编码与后文的Unicode和UTF-8是毫无关系的。</li>
<li>Unicode<br>Unicode字符集（简称为UCS）,国际标准组织于1984年4月成立ISO/IECJTC1/SC2/WG2工作组，针对各国文字、符号进行统一性编码。Unicode编码后的大小是一样的.例如一个英文字母 “a” 和　一个汉字”好”，编码后占用的空间大小是一样的，都是两个字节！Unicode可以用来表示所有语言的字符，而且是定长双字节（也有四字节的）编码，包括英文字母在内。所以可以说它是不兼容iso8859-1编码的，也不兼容任何编码。不过，相对于iso8859-1编码来说，uniocode编码只是在前面增加了一个0字节，比如字母’a’为”00 61”。<br>需要说明的是，定长编码便于计算机处理（注意GB2312/GBK不是定长编码），而unicode又可以用来表示所有字符，所以在很多软件内部是使用unicode编码来处理的，比如java。Unicode当然是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样， 比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字“严”。具体的符号对应表，可以查询 unicode.org，或者专门的汉字对应表。 <a href="http://www.chi2ko.com/tool/CJK.htm" target="_blank" rel="external">http://www.chi2ko.com/tool/CJK.htm</a></li>
<li>Unicode的问题<br>需要注意的是，Unicode只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。比如，汉字“严”的unicode是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。这里就有两个严重的问题，第一个问题是，如何才能区别unicode和ascii？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。 </li>
<li>UTF-8<br>互联网的普及，强烈要求出现一种统一的编码方式。UTF-8就是在互联网上使用最广的一种unicode的实现方式。其他实现方式还包括UTF-16和UTF-32，不过在互联网上基本不用。重复一遍，这里的关系是，UTF-8是Unicode的实现方式之一。UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。UTF-8的编码规则很简单，只有二条：<br>1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。<br>2）对于n字节的符号（n&gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。<br>下表总结了编码规则，字母x表示可用编码的位。<br>Unicode符号范围 | UTF-8编码方式<br>(十六进制) | （二进制）<br>——————————+——————————————————————-<br>0000 0000-0000 007F | 0xxxxxxx<br>0000 0080-0000 07FF | 110xxxxx 10xxxxxx<br>0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx<br>0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx<br>下面，还是以汉字“严”为例，演示如何实现UTF-8编码。已知“严”的unicode是4E25（100111000100101），根据上表，可以发现 4E25处在第三行的范围内（0000 0800-0000 FFFF），因此“严”的UTF-8编码需要三个字节，即格式是“1110xxxx 10xxxxxx 10xxxxxx”。然后，从“严”的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，“严”的UTF-8编码是 “11100100 10111000 10100101”，转换成十六进制就是E4B8A5。</li>
<li>Unicode与UTF-8之间的转换<br>通过上一节的例子，可以看到“严”的Unicode码是4E25，UTF-8编码是E4B8A5，两者是不一样的。它们之间的转换可以通过程序实现。在Windows平台下，有一个最简单的转化方法，就是使用内置的记事本小程序Notepad.exe。打开文件后，点击“文件”菜单中的“另存为”命令，会跳出一个对话框，在最底部有一个“编码”的下拉条。里面有四个选项：ANSI，Unicode，Unicode big endian 和 UTF-8。（这个方法还可以解决一些数据库导出表的乱码问题）<br>1）ANSI是默认的编码方式。对于英文文件是ASCII编码，对于简体中文文件是GB2312编码（只针对Windows简体中文版，如果是繁体中文版会采用Big5码）。<br>2）Unicode编码指的是UCS-2编码方式，即直接用两个字节存入字符的Unicode码。这个选项用的little endian格式。<br>3）Unicode big endian编码与上一个选项相对应。我在下面会解释little endian和big endian的涵义。<br>4）UTF-8编码，也就是上面谈到的编码方法。<br>选择完”编码方式“后，点击”保存“按钮，文件的编码方式就立刻转换好了。</li>
<li>Little endian和Big endian<br>上已经提到，Unicode码可以采用UCS-2格式直接存储。以汉字”严“为例，Unicode码是4E25，需要用两个字节存储，一个字节是4E，另一个字节是25。存储的时候，4E在前，25在后，就是Big endian方式；25在前，4E在后，就是Little endian方式。这两个古怪的名称来自英国作家斯威夫特的《格列佛游记》。在该书中，小人国里爆发了内战，战争起因是人们争论，吃鸡蛋时究竟是从大头(Big-Endian)敲开还是从小头(Little-Endian)敲开。为了这件事情，前后爆发了六次战争，一个皇帝 送了命，另一个皇帝丢了王位。<br>因此，第一个字节在前，就是”大头方式“（Big endian），第二个字节在前就是”小头方式“（Little endian）。那么很自然的，就会出现一个问题：计算机怎么知道某一个文件到底采用哪一种方式编码？ Unicode规范中定义，每一个文件的最前面分别加入一个表示编码顺序的字符，这个字符的名字叫做”零宽度非换行空格“（ZERO WIDTH NO-BREAK SPACE），用FEFF表示。这正好是两个字节，而且FF比FE大1。如果一个文本文件的头两个字节是FEFF，就表示该文件采用大头方式；如果头两个字节是FFFE，就表示该文件采用小头方式。</li>
<li>实例<br>打开”记事本“程序Notepad.exe，新建一个文本文件，内容就是一个”严“字，依次采用ANSI，Unicode，Unicode big endian和UTF-8编码方式保存。然后，用文本编辑软件UltraEdit中的“十六进制功能”，观察该文件的内部编码方式。<br>1）ANSI：文件的编码就是两个字节“D1CF”，这正是“严”的GB2312编码，这也暗示GB2312是采用大头方式存储的。<br>2）Unicode：编码是四个字节“FF FE 25 4E”，其中“FFFE”表明是小头方式存储，真正的编码是4E25。<br>3）Unicode big endian：编码是四个字节“FE FF 4E 25”，其中“FEFF”表明是大头方式存储。<br>4）UTF-8：编码是六个字节“EF BB BF E4 B8 A5”，前三个字节“EF BB BF”表示这是UTF-8编码，后三个“E4B8A5”就是“严”的具体编码，它的存储顺序与编码顺序是一致的</li>
<li>GBK<br>GBK编码(Chinese Internal Code Specification)是中国大陆制订的、等同于UCS的新的中文编码扩展国家标准。gbk编码能够用来同时表示繁体字和简体字，而gb2312只能表示简体字，gbk是兼容gb2312编码的。GBK工作小组于1995年10月，同年12月完成GBK规范。该编码标准兼容GB2312，共收录汉字 21003个、符号883个，并提供1894个造字码位，简、繁体字融于一库。Windows95/98简体中文版的字库表层编码就采用的是GBK，通过GBK与UCS之间一一对应的码表与底层字库联系。英文名：Chinese Internal Code Specification中文名：汉字内码扩展规范1.0版<br>双字节编码，GB2312-80的扩充，在码位上和GB2312-80兼容<br>范围：8140~FEFE（剔除xx7F）共23940个码位包含21003个汉字，包含了ISO/IEC 10646-1中的全部中日韩汉字。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>很多人在编程的过程中一定有过被汉字编码困扰过，有时莫名其妙的就会出现一些乱码，今天我就把几个常见的编码简单介绍一下。</p>
<ol>
<li>ASCII码<br>我们知道，在计算机内部，所有的信息最终都表示为一个二进制的字符串。每一个二进制位（bit）有0和 1两种状态，]]>
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[舟山之行]]></title>
    <link href="http://yoursite.com/2015/06/01/zhoushan/"/>
    <id>http://yoursite.com/2015/06/01/zhoushan/</id>
    <published>2015-06-01T07:04:46.000Z</published>
    <updated>2015-06-01T07:28:26.990Z</updated>
    <content type="html"><![CDATA[<p>转眼间，离上次的青岛海边的毕业旅行正好一年了，又一次的说走就走的旅行，体验了不一样的海边。舟山的人很淳朴，主要都是渔民，而此时正值休渔期，他们也都在休整着，他们平时捕鱼的时候，一般出去一星期才回来一趟，生活很是艰苦。舟山的环境优美，空气清新，特别怡人。这里还有佛教名山普陀山，沙雕故乡朱家尖，桃花岛还是诸多金庸小说的拍摄地。<br>朱家尖，我们第一天的游玩地，每年的7月沙雕文化节都会在这里举办。我们主要去了南沙和大青山景区。舟山的沙滩特别细软，跟面粉似的，走在上面没有搁脚的感觉，十分舒服。这是我毕业旅行后的再一次来到海边，没有下海，就在海边走了走，欣赏了沙雕广场的沙雕艺术品，正好第二届浙江海洋运动会在举行，我们欣赏了沙滩排球比赛。最后买了几个沙雕艺术品，景区的纪念品竟然一点都不是很贵，这里的人确实很淳朴，不会乱砍游客。然后我们去了大青山景区，很幸运一路搭着别人的车去的，那天的大青山云雾缭绕，到了山上感觉走在仙境一般，看海景也不一样，瞭望远处，视野也很开阔。<br><img src="/picture/1.JPG" alt=""> <img src="/picture/2.JPG" alt=""><br>普陀山，我们第二天的游玩地，是佛教四大名山之一（中国佛教四大名山分别是山西五台山、浙江普陀山、四川峨眉山、安徽九华山，分别供奉文殊师利菩萨、观世音菩萨、普贤惠菩萨、地藏王菩萨）。这里供奉着观世音菩萨，南海观音是普陀的标志，来这里的人少不了的一件事就是拜佛，拜佛需要我们心境纯净。寺庙我们就去了普济禅寺，我感觉这里景点确实有点坑，进入普陀已经买了160的门票，进入里面的每个景点竟然还需要门票。然后我们又沿途逛了逛，玩了会沙滩，就坐船回去了。来到了传说中的沈家门渔港，由于正值休渔期，渔船星罗密布，蔚为壮观，渔民也在休整着，修补着渔网，正好我们在岸边休息，跟他们聊了会，他们平时捕鱼时一般出海一星期才回来一趟，生活真是艰苦。晚上就在沈家门吃的著名的海鲜排挡，真是坑啊，3个人几乎没吃什么花了385，虽然在舟山，但是海鲜还是很贵。<br><img src="/picture/3.JPG" alt=""> <img src="/picture/4.JPG" alt=""> <img src="/picture/5.JPG" alt=""> <img src="/picture/6.JPG" alt=""><br>桃花岛，耳熟能详的岛名，各地好像也有很多的盗版，我们第三天来到了真正的桃花岛，金庸笔下的很多小说也都是在这里拍摄的。去桃花岛的船相当不错，我们可以走出船舱到平台上看海景，看看海面风景，海轮在茫茫的大海上很是渺小。到桃花岛我们先去了桃花峪景区，这里观看海景更是不一样，还有各种的风景，相当不错。然后又去了射雕城，这里就是金庸小说的拍摄地，确实很多电视剧中的场景都能在这里找到原型。这里的湖鱼真是多啊，有游客在喂食，引得这些鱼抢食，那抢的真是凶啊，好壮观。射雕城也不是很大，主要就是游览一下风景。然后我们就乘船坐车回去了，又一次经过舟山跨海大桥，十分壮观，距离还很长。<br><img src="/picture/7.JPG" alt=""> <img src="/picture/8.JPG" alt=""> <img src="/picture/9.JPG" alt=""> <img src="/picture/10.JPG" alt=""><br>每一次的旅行都是一次不同生活的体验，也正如网上常说的旅行的意义在于对不同世界和生活的体验与感受。所以现在的我也越来越喜欢看小说和旅游了，因为以后工作了很少有时间去做这些事了，也因为我们每个人的生活都局限于自己单调的世界里，小说和旅游能让我们体验到与我们不同的世界，感受一下他们的生活。正如舟山渔民艰苦的捕鱼生活，蕴育着他们热情，淳朴的民风。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>转眼间，离上次的青岛海边的毕业旅行正好一年了，又一次的说走就走的旅行，体验了不一样的海边。舟山的人很淳朴，主要都是渔民，而此时正值休渔期，他们也都在休整着，他们平时捕鱼的时候，一般出去一星期才回来一趟，生活很是艰苦。舟山的环境优美，空气清新，特别怡人。这里还有佛教名山普陀山]]>
    </summary>
    
      <category term="旅行" scheme="http://yoursite.com/tags/%E6%97%85%E8%A1%8C/"/>
    
      <category term="旅行" scheme="http://yoursite.com/categories/%E6%97%85%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[即时通讯——Openfire + Spark]]></title>
    <link href="http://yoursite.com/2015/05/19/IM/"/>
    <id>http://yoursite.com/2015/05/19/IM/</id>
    <published>2015-05-19T11:18:35.000Z</published>
    <updated>2015-05-19T11:27:15.329Z</updated>
    <content type="html"><![CDATA[<p>即时通讯( Instant Messaging，IM)通常被叫做IM，是两个人通过网络实时地进行同步交流的软件，也是目前国内外互联网用户使用率最高的网络软件。而我毕业设计就是和IM相关的，今天和大家分享一下openfire和spark这2个IM系统的基础软件。<br>Openfire 是遵从GPL 协议的开源软件，是用Java开发的实时协作服务器。它采用了开源的 XMPP 协议来开发即时通讯服务器。由于是采用开放的 XMPP 协议，可以使用各种支持 XMPP 协议的 IM 客户端软件登录服务。可以使用它轻易地构建高效率的即时通讯服务器。Openfire 安装和使用都非常简单，并利用Web进行管理，单台服务器可支持上万并发用户。<br>Spark 是一个开源的、跨平台的即时通讯客户端软件，可以应用在各种商业和组织机构中。它内建了群组聊天、电话集成，又有很强的安全性。它还给终端用户提供了一些人性化的服务，比如拼写检查、群组聊天室的书签标注和选项卡式的对话窗口。配合开源的Openfire，Spark 非常容易部署和使用。</p>
<ol>
<li>Openfire 的安装与配置<br>装 Openfire 之前，先安装 Java 的 JRE 环境，也可以下载包含 JRE 的 Openfire 文件。从网站<a href="http://www.igniterealtime.org/downloads/index.jsp" target="_blank" rel="external">http://www.igniterealtime.org/downloads/index.jsp</a>下载最新版本的Openfire。下载的文件是个可执行文件，双击安装，第一步选择简体中文，其他按照默认设置一步步安装即可。最后一步选择执行 Openfire，界面如图：<br><img src="/picture/qidong.jpg" alt=""><br>Openfire 支持完全的 Web配置。直接点击界面中的LaunchAdmin即可开始通讯服务器的配置。登入管理界面即开始配置向导。语言选择为简体中文;服务器设置保持默认即可; 数据库设置里面有两个选择，标准数据库连接和嵌入的数据库。笔者选择标准数据库连接，因为本文要用 MySQL数据库，这里填入服务器的IP或者域名、选择建好的数据库名、数据库的用户名和密码，这样就可以用MySQL作为数据库服务器;特性设置里面保持默认即可; 管理员账户为admin，只要填入电子邮箱和设置密码即可;最后一步是安装完成。这样就可以登录到管理控制台。在这个控制台里可以对服务器、用户、分组、插件等功能做设置。管理控制台的界面如图<br><img src="/picture/openfire.png" alt=""></li>
<li>Spark 的安装与配置<br>从<a href="http://www.igniterealtime.org/downloads/index.jsp" target="_blank" rel="external">http://www.igniterealtime.org/downloads/index.jsp</a>下载 Spark 的最新版本，选择 Windows 版本。Spark的安装过程比较简单，登录的时候服务器地址选择安装Openfire时设置的IP或域名即可。Spark 是个IM 客户端，具备了几乎一切即时通讯工具的功能。利用Spark菜单的Plugin 功能，可以得到很多实用插件，比如拼写检查、即时翻译等功能。Spark最吸引人的一个功能就是可以整合很多第三方 IM 账户，可以让用户和 MSN、Yahoo、ICQ、GTalk等 IM 用户互相通信，这个特性解决了各种 IM 之间交互通信的问题。整合国内的 QQ、人人网 IM 等还在测试阶段，不能正式使用，因为QQ等是采用封闭协议的，还有待进一步完善。<br>Openfire 即时通讯服务器所需要的几乎所有的插件都可以从<a href="http://www.igniterealtime.org/projects/openfire/plugins.jsp" target="_blank" rel="external">http://www.igniterealtime.org/projects/openfire/plugins.jsp</a>下载,大家可以根据自己需要从上面下载相应的插件，然后把文件复制到Openfire/Plugins文件夹下或者从Openfire控制台插件标签里直接上传部署，重启Openfire 服务即可。<br>Openfire + Spark 是跨平台的，支持多版本操作系统。这个也是我自己的毕业设计涉及的内容，感觉他的功能很强大，而且是开源的，可以根据自己的需要设计自己及时通讯系统。所以分享给大家。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>即时通讯( Instant Messaging，IM)通常被叫做IM，是两个人通过网络实时地进行同步交流的软件，也是目前国内外互联网用户使用率最高的网络软件。而我毕业设计就是和IM相关的，今天和大家分享一下openfire和spark这2个IM系统的基础软件。<br>Ope]]>
    </summary>
    
      <category term="IM" scheme="http://yoursite.com/tags/IM/"/>
    
      <category term="IM" scheme="http://yoursite.com/categories/IM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android之事件和intent]]></title>
    <link href="http://yoursite.com/2015/05/15/shijian/"/>
    <id>http://yoursite.com/2015/05/15/shijian/</id>
    <published>2015-05-15T09:20:11.000Z</published>
    <updated>2015-05-15T09:24:00.317Z</updated>
    <content type="html"><![CDATA[<p>在Android中与界面编程息息相关的就是事件处理了，当用户在程序界面上执行各种操作时，应用程序必须为用户动作提供响应动作。Android提供了两种方式的事件处理：基于监听的事件处理和基于回调的事件处理<br>基于监听的事件处理模型编程步骤：</p>
<ul>
<li>获取界面组件（事件源），即被监听的对象，任何组件都可以。</li>
<li>实现监听器类，即一个特殊的Java类，必须实现XxxListener接口，事件编程的关键。</li>
<li>调用事件源的setXxxListener方法将事件监听器对象注册给组件（事件源），一般调用setXxxListener（XxxListener）方法即可。</li>
</ul>
<p>而基于回调的事件处理，关于回调机制我在上一篇微博中已经讲了，简单的说就是在组件的属性中直接定义事件，这也是现在Android经常用到的。</p>
<ol>
<li>Handle、Looper与MessageQueue之间的关系及工作原理<br>Android中不允许在子线程中更新界面组件，要在子线程中更新界面组件，需要用Handle对象实现。因为要让handle正常工作，当前线程中必须有一个Looper对象，所以使用handle步骤是：调用Looper的prepare()方法为当前线程创建Looper对象，创建Looper对象时，它的构造器会创建与之配套的MessageQueue；然后创建handle子类的实例，重写handleMessage()方法，该方法负责处理来自其他线程的消息。最后调用Looper的Loop()方法启动Looper。<br>在Android中UI线程主要负责处理用户的按键事件、用户触屏事件及屏幕绘图事件等，因此其他操作不能阻塞UI线程，否则UI界面会停止响应—这样用户感觉会非常糟糕，所以一定牢记：千万不要在UI线程中执行一些耗时的操作</li>
<li>Intent简介<br>Intent通过指定action属性（其实就是一个普通的字符串），实现把该intent与具体的activity分离，从而提供高层次的解耦（低耦合）。当Android应用不管是启动activity，还是启动service、BroadcastReceiver组件时，Android系统都是由intent来实现的。简单的说，Android使用intent封装了应用程序的“启动意图”，这种“意图”并未直接与任何程序组件耦合。而intent的属性都是通过在 <intent-filter...>属性进行配置的。</intent-filter...></li>
</ol>
<p>最后和大家分享一个比较酷炫的东西和一个小技术，在朋友圈里，经常见到一些html5海报，浏览者通过手指的滑动实现页面的切换效果，由于该效果和ppt演示十分相似，也有人称之为html5PPT。而制作这个大家可以看看这个<a href="http://chuansong.me/n/674095" target="_blank" rel="external">http://chuansong.me/n/674095</a>，做出来的效果真是棒棒哒。<br>如何将MySQL中的数据导出为xls格式的：<br>select *from 数据库.表名（world.question_attribute_value） into outfile ‘d:test.xls’;<br>这个时候xls文件是utf-8编码的，用excel打开，会出现乱码。把test.xls以文本方式打开，然后另存为，在编码选择ANSI编码，保存。ok，再用excel打开，乱码问题，烟消云散。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在Android中与界面编程息息相关的就是事件处理了，当用户在程序界面上执行各种操作时，应用程序必须为用户动作提供响应动作。Android提供了两种方式的事件处理：基于监听的事件处理和基于回调的事件处理<br>基于监听的事件处理模型编程步骤：</p>
<ul>
<li>获取]]>
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解activity]]></title>
    <link href="http://yoursite.com/2015/05/12/activity/"/>
    <id>http://yoursite.com/2015/05/12/activity/</id>
    <published>2015-05-12T08:40:06.000Z</published>
    <updated>2015-05-12T08:54:11.235Z</updated>
    <content type="html"><![CDATA[<p>activity是Android应用的重要的组成单元之一（另外三个是service、broadcastreceive和contentprovider），也是Android应用最常见的组件之一，而对它的生命周期的深刻了解对于Android开发十分重要。<br>首先得说一下Android的回调机制：当开发者需要该组件能响应特定的事件，可以选择性地实现该组件的特定方法，即当用户在该组件上激发某个事件时，该组件上特定的方法就会回调（通俗的讲就是实现某个功能就会调用给功能对应的方法叫回调）。Activity运行过程中所处的不同状态称为生命周期，在不同的状态会回调不同的方法。<br>每个活动在其生命周期中最多可能会有四种状态。</p>
<ol>
<li>运行状态<br>当一个活动位于返回栈的栈顶时，这时活动就处于运行状态。系统最不愿意回收的就是处于运行状态的活动，因为这会带来非常差的用户体验。</li>
<li>暂停状态<br>当一个活动不再处于栈顶位置，但仍然可见时，这时活动就进入了暂停状态。你可能会觉得既然活动已经不在栈顶了，还怎么会可见呢？这是因为并不是每一个活动都会占满整个屏幕的，比如对话框形式的活动只会占用屏幕中间的部分区域。处于暂停状态的活动仍然是完全存活着的，系统也不愿意去回收这种活动（因为它还是可见的，回收可见的东西都会在用户体验方面有不好的影响），只有在内存极低的情况下，系统才会去考虑回收这种活动。</li>
<li>停止状态<br>当一个活动不再处于栈顶位置，并且完全不可见的时候，就进入了停止状态。系统仍然会为这种活动保存相应的状态和成员变量，但是这并不是完全可靠的，当其他地方需要内存时，处于停止状态的活动有可能会被系统回收。</li>
<li>销毁状态<br>当一个活动从返回栈中移除后就变成了销毁状态。系统会最倾向于回收处于这种状态的活动，从而保证手机的内存充足。</li>
</ol>
<p>Activity 类中定义了七个回调方法，覆盖了活动生命周期的每一个环节，下面我来一一<br>介绍下这七个方法</p>
<ol>
<li>onCreate()<br>这个方法你已经看到过很多次了，每个活动中我们都重写了这个方法，它会在活动第一次被创建的时候调用。你应该在这个方法中完成活动的初始化操作，比如说加载布局、绑定事件等。</li>
<li>onStart()<br>这个方法在活动由不可见变为可见的时候调用。</li>
<li>onResume()<br>这个方法在活动准备好和用户进行交互的时候调用。此时的活动一定位于返回栈的栈顶，并且处于运行状态。</li>
<li>onPause()<br>这个方法在系统准备去启动或者恢复另一个活动的时候调用。我们通常会在这个方法中将一些消耗 CPU 的资源释放掉，以及保存一些关键数据，但这个方法的执行速度一定要快，不然会影响到新的栈顶活动的使用。</li>
<li>onStop()<br>这个方法在活动完全不可见的时候调用。它和onPause()方法的主要区别在于，如果启动的新活动是一个对话框式的活动，那么onPause()方法会得到执行，而onStop()方法并不会执行。</li>
<li>onDestroy()<br>这个方法在活动被销毁之前调用，之后活动的状态将变为销毁状态。</li>
<li>onRestart()<br>这个方法在活动由停止状态变为运行状态之前调用，也就是活动被重新启动了。下面的图可以帮你很好的了解该调用过程：<br><img src="/picture/zhouqi.png" alt=""></li>
</ol>
<p>以上七个方法中除了 onRestart()方法，其他都是两两相对的，从而又可以将活动分为三种生存期。</p>
<ol>
<li>完整生存期<br>活动在 onCreate()方法和onDestroy()方法之间所经历的，就是完整生存期。一般情况下，一个活动会在 onCreate()方法中完成各种初始化操作，而在onDestroy()方法中完成释放内存的操作。</li>
<li>可见生存期<br>活动在 onStart()方法和onStop()方法之间所经历的，就是可见生存期。在可见生存期内，活动对于用户总是可见的，即便有可能无法和用户进行交互。我们可以通过这两个方法，合理地管理那些对用户可见的资源。比如在onStart()方法中对资源进行加载，而在onStop()方法中对资源进行释放， 从而保证处于停止状态的活动不会占用过多内存。</li>
<li>前台生存期<br>活动在 onResume()方法和onPause()方法之间所经历的，就是前台生存期。在前台生存期内，活动总是处于运行状态的，此时的活动是可以和用户进行相互的，我们平时看到和接触最多的也这个状态下的活动。<br>Android中的活动是可以层叠的，以栈来管理活动，没启动一个新活动就会覆盖在原活动之上，点击back会销毁最上面的活动，下面展示了如何管理活动操作的。<br><img src="/picture/zhan.png" alt=""><br>而不同的活动之间是通过bundle对象来通信传递数据的。</li>
</ol>
<p>最后所谓温故知新，我将servlet与activity比较一下：</p>
<ol>
<li>activity是Android的窗口容器，因此activity最终以窗口形式显示出来，而servlet并不会生成应用界面，只向浏览器生成文本响应。</li>
<li>activity的本质是通过各种界面组件来搭建界面；而servlet则主要以IO流向浏览者生成文本响应，用户看到的界面其实是浏览器负责生成的。</li>
<li>activity之间的跳转主要通过intent对象来控制；而servlet之间跳转则主要由用户请求来控制。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>activity是Android应用的重要的组成单元之一（另外三个是service、broadcastreceive和contentprovider），也是Android应用最常见的组件之一，而对它的生命周期的深刻了解对于Android开发十分重要。<br>首先得说一下An]]>
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android入门]]></title>
    <link href="http://yoursite.com/2015/05/08/rumen/"/>
    <id>http://yoursite.com/2015/05/08/rumen/</id>
    <published>2015-05-08T07:12:59.000Z</published>
    <updated>2015-05-08T07:46:15.239Z</updated>
    <content type="html"><![CDATA[<p>时间好快，转眼来南瑞实习已经两个多月了，过上了每天上班的生活，偶尔有时会加班，但是每天的生活觉得还是很充实的，虽然平淡，但是每天都能有所收获即使只是那么一点点。为了讲述Android的完整性，我把上次在新浪写的弄过来，这也是受到一些大牛的启发，我要坚持写下去，记录下我学习过程中的收获，遇到的问题包括编程过程中遇到的错误，调试的过程等，以及一些感悟，希望通过这样总结平时的学习，记录下学习生活中的点点滴滴。<br>今天就讲讲Android的入门吧。</p>
<ul>
<li>首先就是搭建开发环境，这个任何一本书都有介绍，去Android官网下一个SDK工具包，地址：<a href="http://developer.android.com/sdk/" target="_blank" rel="external">http://developer.android.com/sdk/</a>。然后安装一下，还要配置一下JDK，很简单就不多赘述。说一下我主要参考的书就是《疯狂Android讲义》，也可以参考《第一行代码》，其实最主要的还是要会运用Android的API文档，其实学习任何技术都是一样的，一定要学会查文档，因为有好多方法和属性是根本记不住的，所以我学习的时候，把每个方法都浏览一遍（一般Android的方法根据名称就能知道它的用途），然后编程的时候根据需求用到的时候去查API文档或者参考书寻找对应的方法和属性，或者百度。其实编程编多了好像也就是那么回事，最近网上不是流传着编程的步骤：<blockquote>
<p>1)    打开Google。<br>2)    输入stackoverflow，进行搜索。<br>3)    进入网站，搜索需求的代码，copy到本地进行调试，改错等。<br>4)    调试不成功，接着重复2到4步骤，重新搜索。<br>5)    有没有搜不到的情况，答：不可能。</p>
</blockquote>
</li>
</ul>
<p>虽然是个段子，但是stackoverflow确实很强大，你有什么错误可以在上面找。<br>环境搭好后，需要你建一个虚拟机（就是一个虚拟手机，可以在上面运行你的程序），也很简单，可以参考书上说明或者百度。建好后运行虚拟机就跟真的手机一样<br><img src="/picture/jiemian.jpg" alt=""></p>
<ul>
<li>建立项目<br>一般所有的书上都会介绍建立helloworld这个第一个Android项目，这里根据书上的介绍一步一步建立就好了，我想分享一下Android的项目结构，其实它也是典型的MVC结构，类似于JavaWeb运用SSH的结构，目的为了降低耦合性。<br><img src="/picture/ziyuan.jpg" alt=""><br>这就是一个项目中的所有文件，src中放的是Java代码，就是后台控制的内容。Gen目录下的文件是自动生成的，你不用去管它也不要去修改它。Assets和bin不需要关注。Libs下放的是第三方jar包。Res是比较重要的，内容有比较多，前面的gen目录下的R.java也是根据这个目录下的文件自动生成的。以我的理解，大家把图片都放在图片放在 drawable-hdpi 目录下，布局放在 layout 目录下，字符串和其他的XML布局放在 values 目录下。AndroidManifest.xml也是经常用到的文件，涉及到的内容我也没学到呢，等学到了再说吧。project.properties这个文件非常地简单，就是通过一行代码指定了编译程序时所使用的 SDK 版本。<br>还有就是在编程的过程中一定要学会用自动提示功能，这样能避免很多错误，因为根据自动提示会自动把一些用到的包导进去和大小写问题也会自动解决。<br>最后分享一些网址：<br>这个是卡耐基梅隆大学计算机学院语言技术系的资源大全：包括大量的NLP开源软件工具包，基础数据集，论文集，数据挖掘教程，机器学习资源：<a href="http://islpc21.is.cs.cmu.edu:3000/lti_catalogue。" target="_blank" rel="external">http://islpc21.is.cs.cmu.edu:3000/lti_catalogue。</a><br>由于在国企，Google等外国网站很困难（国企对于信息安全要求太严格了），导致上Google搜索问题出现困难，就用了google 镜像网站：repigu.com或者nan.so</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>时间好快，转眼来南瑞实习已经两个多月了，过上了每天上班的生活，偶尔有时会加班，但是每天的生活觉得还是很充实的，虽然平淡，但是每天都能有所收获即使只是那么一点点。为了讲述Android的完整性，我把上次在新浪写的弄过来，这也是受到一些大牛的启发，我要坚持写下去，记录下我学习过]]>
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[My first blog]]></title>
    <link href="http://yoursite.com/2015/05/07/my_first_blog/"/>
    <id>http://yoursite.com/2015/05/07/my_first_blog/</id>
    <published>2015-05-07T14:16:33.000Z</published>
    <updated>2015-05-08T07:50:39.251Z</updated>
    <content type="html"><![CDATA[<p>之前由于在新浪上开始写博客，写博客是因为之前经常看到一些大牛的博客，让我受益匪浅，就跟读文学类的书籍一样，带领你走进另一个你未曾经历过的世界，也许这就是我为什么现在特别喜欢看小说的原因吧，而且当你学会分享和教别人的时候，说明你已经差不多掌握了这个技术。后来经过Gavin 的建议让我用github来搭博客，主要是自己的博客，没有任何广告，看的也很舒服。经过努力，今天终于把博客建好了。今天就用我的在github上的第一篇博客来记录一下我的建博客的经历和遇到的问题的解决方案（更为详细的步骤大家还是参考原文吧<a href="http://linjiangxian998.com/" target="_blank" rel="external">linjiangxian</a>和<a href="http://zipperary.com/categories/hexo/" target="_blank" rel="external">zipperary</a>），以及我最近学习的情况，还有强烈推荐大家学习一下Markdown语言，棒棒哒的<strong>优点</strong>：</p>
<ul>
<li>纯文本，所以兼容性极强，可以用所有文本编辑器打开。</li>
<li>让你专注于文字而不是排版。</li>
<li>格式转换方便，Markdown 的文本你可以轻松转换为 html、电子书等。</li>
<li>Markdown 的标记语法有极好的可读性<br>建博客的的步骤分为：</li>
</ul>
<ol>
<li>在<a href="https://github.com/" target="_blank" rel="external">github</a>在注册一个账号，然后创建一个repository。（github是世界上最大的代码托管网站。我的理解是和网盘差不多，只不过上面存放的都是代码。国内有类似的常用的网站是gitcafe）。</li>
<li>安装Node.js（hexo是一款基于Node.js的博客框架，所以要先安装Node.js环境），安装完之后请重启电脑一次。</li>
<li>安装mygit，我们将在这个软件输入一些命令进行操作（安装完成后，在空白处右击鼠标选择Git Bash蹦出一个类似命令行窗口的东西，就说明Git安装成功）</li>
<li>创建hexo文件夹，在你喜爱的文件夹下（如E:\hexo），在E:\hexo（你自己的文件可能跟我不一样）内点击鼠标右键，选择Git bash，执行以下指令。Hexo会自动在目标文件夹建立网站所需要的所有文件:<br><pre><code>hexo init </code></pre><br><strong>安装依赖包</strong><br><pre><code>npm install </code></pre><br><strong>执行以下命令(如E:\hexo)</strong><br><pre><code>1 hexo g<br>2 hexo s<br></code></pre><br>g即是generate，可以写整个单词generate，也可以只写g。s也是同理，即是server。以上两步就建起了本地博客，按照提示可以在浏览器中输入<a href="http://localhost:4000查看" target="_blank" rel="external">http://localhost:4000查看</a></li>
<li>部署博客到github上，用文本编辑器打开_config.yml(如E:\hexo下)。你在部署时，要把下面的tiantangzhiniao都换成你的账号名<br><pre><code>deploy:<br>type: git<br>repo: <a href="https://github.com/tiantangzhiniao/tiantangzhiniao.github.io.git" target="_blank" rel="external">https://github.com/tiantangzhiniao/tiantangzhiniao.github.io.git</a><br>branch: master<br></code></pre><br>然后hexo g和hexo d，接着输入账号和密码即可完成部署</li>
<li>优化主题和插件（可以看<a href="http://zipperary.com/categories/hexo/" target="_blank" rel="external">zipperary</a>，写的很详细）</li>
</ol>
<p>这里我主要说一下我在搭建过程的遇到的问题</p>
<ol>
<li>首先每次改_config.yml中的属性时都要加一个空格（就因为这个错误，我在部署的时候一直报错，导致我检查中英文标点和大小写弄了半天），而且在用Markdown标签时也不要忘了加一个空格。</li>
<li>初次搭建时确实可能遇到各种问题，也可能感觉很困难，但是当你搭建成功后会发现原来也很简单嘛。</li>
<li>优化和美观确实比较繁琐，大家可以用一些现成的主题就方便多了，一般的插件都是在widgets下配的。</li>
<li>出现乱码的，不要使用 windows 中的「记事本」打开并编辑文件，推荐使用 sublime text，很简单。如果已经在「记事本」中编辑过，需要使用 sublime text 转码为「utf8」。<br>我讲的很粗略，大家可以去我推荐那个看看，最近我会把我又学习的Android的东西分享一下，学习Android的过程中也逐渐明白了智能手机的一些原理，感觉很好玩！<br>最后非常感谢Gavin 和linjiangxian让我最后顺利的搭建成功。今晚和师父聊了一个多小时，终于把论文题目定下来，真的好感谢师父（虽然他看不到），让我知道了好多，还了解了南瑞的一些情况。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前由于在新浪上开始写博客，写博客是因为之前经常看到一些大牛的博客，让我受益匪浅，就跟读文学类的书籍一样，带领你走进另一个你未曾经历过的世界，也许这就是我为什么现在特别喜欢看小说的原因吧，而且当你学会分享和教别人的时候，说明你已经差不多掌握了这个技术。后来经过Gavin 的]]>
    </summary>
    
      <category term="建博客" scheme="http://yoursite.com/tags/%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="建博客" scheme="http://yoursite.com/categories/%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
</feed>